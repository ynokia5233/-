目录
一、	自动化框架设计原则	3
1.1	用例层	4
1.2	数据层	4
1.3	逻辑层	5
二、	接口封装原则	6
1.1	关键字命名	6
1.2	消息头	6
1.3	组url	7
1.4	组body	7
1.5	发送消息	8
1.6	入参和返回值	10
1.7	注释文档	10
三、	Keyword设计原则	11
1.1	【规则】编写的Keyword放在resource文件夹里面,按特性组划分。	11
1.2	【规则】RIDE里面编写的关键字命名以kw为前缀，单词之间_分隔，并且有跟业务相关有意义的词汇组成。	11
1.3	【规则】关键字编写必须要有足够的documentation描述，包括功能描述、入参解释、出参解释、示例。	12
1.4	【建议】要尽量考虑该关键字对不同调用情况的适配，降低关键字的冗余。	13
四、	脚本写作原则	14
【规则1】：自动化脚本中不能直接使用环境数据，需要使用宏引用的方式。严禁出现魔鬼数字。	14
【规则2】：对被测环境进行的修改，一定在本用例中进行恢复，保证环境数据在脚本执行前和执行后环境数据不发生任何变化。	14
【规则3】：避免脚本之间的相互关联，一个脚本包含一个测试用例，保证任意抽取一个测试脚本除环境问题外均能正常运行。	14
【规则4】：自动化用例的设计，必须是一个测试步骤对应一个预期输出，不允许出现一个测试步骤对应多个预期输出，或多个测试步骤对应一个预期输出的情况，以此来提高脚本的可阅读性。	14
【规则5】RF的脚本只在RIDE里面编辑，不在本地文件进行编辑。	14
【规则6】脚本名称必须与TMSS上的测试用例ID相对应	14
【规则7】documentation描述应该包括测试用例名称、编写日期、责任人,复杂、用例建议增加主要的检查点介绍。	15
【规则8】脚本的标签最少应包括测试用例级别。	16
【规则9】在脚本中间，在开始一个新功能点或一个新界面之前，要有一行的注释。	16
【规则10】预置条件中仅调用一个KW的，在脚本的“Setup”中填写，同理脚本中环境恢复进一个KW的在脚本的“Teardown”中填写。	17
【规则11】预置条件和环境恢复中调用多个KW，在脚本同级目录下编写以“Setup_用例ID”和“Teardown_用例ID”的关键字，在脚本的Setup和Teardown中调用。	17
【规则12】每个最小测试集的脚本数一般在30个以内。	17
【规则13】非最小测试集不能有标签和测试集的setup和teardown。	18
【规则14】宏定义文件放到resource目录下，范围相近的常量，放在同一文件里面；	18
【规则15】入厂脚本中不能有多余的注释：	19








FusionSphere自动化测试设计规范
一、	自动化框架设计原则
框架图：
System	Layer
Robot Framework	Cases

	Keywords
Resources
Python Library	Keywords

	           Modules
Behavior
	Request & Response Driver

	External Libraries & Tools
httplib, Crypto, robot, robotide, selenium …

 


自动化框架设计的基本理念就是分层，解耦。在做到层次间调用适配的情况下, 替换任意一层或多层, 框架可以正常工作, 不会影响整体功能。
1.1	用例层
用例层存放各个特性用例的自动化脚本，以及执行用例过程中，用户自己封装的用于简化脚本写作流程、减小用例规模、增加脚本可读性的用户关键字。
相关文件存储路径为工程目录下的suite文件夹，原则上用例的路径应当与TMSS上的用例树中的可自动化用例一一对应，如下图所示：
 
1.2	数据层
数据层所承担的功能与spider中的宏相类似，用于定义脚本执行过程中的环境信息、数据、工具路径等信息。原则上讲，脚本写作应当向代码一样尽量避免出现魔鬼数字。为了移植方便，配置文件按照场景放置在suite文件夹里，不再单独的放在Resource文件夹中
 
1.3	逻辑层
逻辑层在自动化测试框架中对应于Spider中的logic层。
 
不同于R5C00，R5C10自动化采用逻辑层分层设计，将逻辑归类分层为3个层次，分别为：基础层、接口层和业务层。其中接口层存放公共方法类关键字和外部库接入关键字等；接口层为北向接口封装，每一个北向接口对应于一个关键字，以防止接口层逻辑随用例增加而膨胀；业务层关键字能够完成某个完整的业务流程，比如说虚拟机或主机的增删查改，是基础层和接口层关键字的逻辑组合。用例写作时应当优先考虑使用业务层的关键字，因此也需要业务关键字在写作时能够兼容该业务的各种场景。

二、	接口封装原则（太军按照共有云框架补充最新的接口封装方法）
1.1	关键字命名
接口层关键字命名方式为：rest_<method>_<interfaceName>_<action>。
其中method为消息的发送方式（put\get\post\delete）；interfaceName对应于该接口在北向接口文档中的名称。
（后续需要封装fsp的rest关键字，可将其命名为rest_fsp_<method>_<interfaceName>_<action>）
1.2	消息头
对于FC来说，除过创建和删除鉴权，其余接口的消息头都是一样的，因此在我们的框架中，01层的接口关键字的消息头被统一抽象出来作为00层的关键字，这个关键字定义如下：
 
与spider的关键字封装方式不同，RF的接口层关键字在鉴权的处理上采用用例内共享鉴权的方法，即把鉴权的创建和删除操作移到用例里进行，而不在接口关键字内部进行，从而避免脚本运行过程中的重复申请鉴权操作。（上述脚本中的Set Request Header，以及下文中将出现的Set Request Body，HttpLibrary.HTTP.Get/Put/Post/Delete，Get Response Body和Get Response Status关键字均引入自RF库HttpLibrary.HTTP，该库已经通过Base层rest_fc_common.txt引入，接口层关键字只需要引用该文件则可直接使用这些关键字）
默认情况下，在用例开始的时候，用户需要手动使用：
 
来创建鉴权，之后${token}便自动成为所有接口关键字的默认鉴权token，不需要对关键字进行额外的鉴权赋值。但是需要注意，${token}这个变量不能再在用例中做其他用途，一旦被赋了别的值，则可能出现鉴权失败的结果。鉴权关键字默认使用admin用户鉴权，要切换鉴权，需要为其前两个参数分别赋值为鉴权用户名和密码。
综上所述，01层接口关键字写作时，对于消息头的处理仅需要调用关键字rest_fc_set_header即可。
1.3	组url
多数情况下，接口关键字使用的url地址都是固定的，但某些情况下会出现url可伸缩的情况。
对于固定的url，直接通过设置url变量即可。如下图：
 
消息接口的url本质上就是一条字符串，对于url参数较多的情况，可以将url拆分成多个段，每一段分别处理即可。
而对于可伸缩的url，可以通过对入参进行逻辑判断从而确定是否需要增加相应字段的方式来解决。参考rest_interface_template的实现：
 
url_option1是地址的可选字段，当该值为空时url变量自己赋值给自己，所以不增加该字段；不为空时在地址后面添加“&url_option=${url_option}”字段。这里是用的Set Variable If关键字可以根据后面跟随的条件判断来确定需要返回的分支的结果。对于RF中条件语句的写法，请参照《RF脚本中的条件判断的写法》。
1.4	组body
消息的body体是json格式的，所以不能像处理url那样的简单做字符串赋值的处理。Json格式本质上是以字典格式的形态组织的，因此创建body体的时候应当使用关键字Create Dictionary（注：这个关键字需要RF的Collections库支持，base层的rest_fc_common.txt中已经引用了，因此封装接口关键字的时候无需重复引用）。
 
上述语句将一个字典结构的对象“{"body_need":"${body_need}"}}”赋值给reqBody变量。如果消息体中包含多个字段，可以使用以下语句生成字段对象：
 
上述语句中的Set To Dictionary用于将一个键值对“dict_l1：${dict_l1}”添加到${reqBody}变量中，最终该变量中的对象为：
“{"body_need":"${body_need}"，"dict_l1":{"body_need1":"${body_need1}"}}”
大家可以发现dict_li作为reqBody中的一个字段，它对应的值也是一个字典。对Json数据格式的扩充以此类推，加入的键值对可以是单个的字符串、数字、字典和列表，组消息体的时候需要灵活处理（注：常见的消息体字段的形态还有列表变量“[1,2,3…]”，这时只需将Create Dictionary替换为Create List即可）。
消息体的组织同样需要考虑可伸缩字段的情况，处理的方法与组url时的伸缩字段相似。这里我们提供的方法是通过两个关键字的组合：Run Keyword If和Set To Dictionary。请看例子：
 
当条件语句中的body_option变量不为空时，Set To Dictionary子语句被执行，body_option键值对被添加到reqBody中；为空时不做任何操作。
1.5	发送消息
工作进行到这里，消息头、地址和消息体的准备已经完成，万事俱备了。
在发送消息之前还有一个重要步骤要做：
 
第3节中组消息体的步骤向reqBody中赋值的是一个python中的字典对象，但是RF中的HttpLibrary.HTTP中提供的几种发送消息的方法需要使用字符串格式，Stringify Json关键字的功能就是把Json格式的对象字符串化，因此这一步是比不可少的。
发送消息时，推荐使用Base层rest_fc_common.txt中的rest_request关键字。设计01层关键字的初衷是让这层的关键字能够完成所有北向接口操作。为了不使关键字数量膨胀，01层的接口关键字应当与接口文档中的接口一一对应。所以我们规定01层的接口关键字必须自带status参数，默认值为200，状态值判断在关键字内部完成；所有的接口关键字统一以respBody（相应正文）作为返回值，不做数据处理。
因此对消息的发送和返回做了一次封装：
 
HttpLibrary.HTTP库提供的发送消息的方法默认是响应成功关键字才执行成功的（返回20x），响应失败时关键字也会执行失败。Run Keyword And Ignore Error可以在关键字执行失败使忽略错误，继续向下执行。入参method表示消息的发送方式（put\get\post\delete）。该关键字返回消息的状态信息和消息正文。
调用方式如下：
 
当需要测试异常场景的时候，只需在接口参数中将status赋值为预期的状态值即可，无需在单独封装关键字。
1.6	入参和返回值
RF工具在入参设置时，需要注意：
	将必选参数填在可选参数前；
	列表参数必选排在参数列表的最后；
	可选参数必须预置默认值，调用时如果不填该参数，默认值则为预置值。
01层关键字必须以respBody为返回值，这一点请大家注意。
1.7	注释文档
关键字的文档在关键字查询的时候能够直接显示出来，对大家的脚本写作有很大的帮助，因此希望大家在封装好关键字后都能给关键字加上文档信息，格式入下：
【功能描述】
接口关键字模板，提供rest接口写作所需的基本逻辑，帮助大家在封装接口时做参考。
【入参】
${usl_need} 必选，url的必选参数，作为url体；
${body_need} 必选，reqBody的必选参数；
${url_option} 可选，url的可选参数；
${body_option} 可选，reqBody的可选参数；
${site_id} 可选，默认值为vrm_server1.SiteID；
${status} 可选，默认值为200，接口需要的执行结果不为200时需要填写此参数；
【出参】
${respBody} 接口关键字默认返回相应正文
【作者】
l00269716
【日期】
2014/12/30
为使脚本更具可读性，希望大家能在具体的步骤前面加上相应的注释：
 
三、	Keyword设计原则
1.1	【规则】编写的Keyword放在resource文件夹里面,按特性组划分。
正确样例：
 
1.2	【规则】RIDE里面编写的关键字命名以kw为前缀，单词之间_分隔，并且有跟业务相关有意义的词汇组成。
1)	关键字分为6种基本关键字和1种复合关键字: 新增, 删除, 修改, 获取, 提交(应用), 验证, 以及基于这6个关键字的功能组合关键字.
2)	所有关键字以英文命名, 为了与测试库关键字区分, 加上kw_前缀(kw为小写), 除前缀外, 建议后面再加上资源类型来分类
3)	对于基本关键字, 其具体名称根据API文档中的名称决定(例如文档中的英文命名, 或者url路径中能够唯一代表接口名称的英文命名).
4)	若API文档中没有对接口英文命名, 则将文档中的中文命名英文化, 根据上述的6个种类, 分别添加kw_add, kw_del, kw_mod, kw_get, kw_apply, kw_verify前缀. 其中kw_apply有一种特例: 若英文化的名称已经包含对特定的功能提交或应用的意思, 则允许(但不强制)省略apply, 直接以kw_开头.

正确样例：
 
错误样例：
 
1.3	【规则】关键字编写必须要有足够的documentation描述，包括功能描述、入参解释、出参解释、示例。
正确样例：
 
错误样例：
 
1.4	【建议】要尽量考虑该关键字对不同调用情况的适配，降低关键字的冗余。
正确样例：
 
错误样例：
 





四、	脚本写作原则
【规则1】：自动化脚本中不能直接使用环境数据，需要使用宏引用的方式。严禁出现魔鬼数字。
【规则2】：对被测环境进行的修改，一定在本用例中进行恢复，保证环境数据在脚本执行前和执行后环境数据不发生任何变化。
【规则3】：避免脚本之间的相互关联，一个脚本包含一个测试用例，保证任意抽取一个测试脚本除环境问题外均能正常运行。
【规则4】：自动化用例的设计，必须是一个测试步骤对应一个预期输出，不允许出现一个测试步骤对应多个预期输出，或多个测试步骤对应一个预期输出的情况，以此来提高脚本的可阅读性。
【规则5】RF的脚本只在RIDE里面编辑，不在本地文件进行编辑。
原因：RF的脚本对格式要求比较严，在本地文件编辑容易引起格式错误，导致脚本不能正常执行
正确样例：
 
错误样例：
 
【规则6】脚本名称必须与TMSS上的测试用例ID相对应
原因：1、脚本的结构比较清晰和熟悉；
      2、是工厂将自动化执行结果回填TMSS的必要条件
正确样例：
 
错误样例：
 
【规则7】documentation描述应该包括测试用例名称、编写日期、责任人,复杂、用例建议增加主要的检查点介绍。
原因：1、documentation可以帮助别人快速的了解脚本实现的功能和脚本的思路；
      2、可以明确的定位责任人
正确样例：
 
错误样例：
 
【规则8】脚本的标签最少应包括测试用例级别。
原因：1、执行时也可以根据不同Tags来进行自动化测试
注:
用例级别：以Level为前缀，级别数为后缀；如Level1、Level2、Level3
Ok标识该脚本已经调成陈功
入厂标识该脚本可以入厂连跑
作者：脚本编写者，为了方便找到脚本作者定位脚本
正确样例：
    
错误样例：
 
【规则9】在脚本中间，在开始一个新功能点或一个新界面之前，要有一行的注释。
原因：1、在脚本里面适当的注释可以帮助理解脚本编写的思路，使整个脚本结构比较清晰

正确样例：
 
错误样例：
 
【规则10】预置条件中仅调用一个KW的，在脚本的“Setup”中填写，同理脚本中环境恢复进一个KW的在脚本的“Teardown”中填写。
【规则11】预置条件和环境恢复中调用多个KW，在脚本同级目录下编写以“Setup_用例ID”和“Teardown_用例ID”的关键字，在脚本的Setup和Teardown中调用。
在目录中创建方式：
 
在脚本引用方式：
 
【规则12】每个最小测试集的脚本数一般在30个以内。
原因：1、不同最小测试集脚本数量相差较大，会容易导致各个执行机负载不均衡
      2、对于RIDE，超过30个的脚本编写反应就会变的缓慢
正确样例：
 
【规则13】非最小测试集不能有标签和测试集的setup和teardown。
原因：由于在非最小测试集下有标签、setup和teardown，这些就会记录在_init_文件里面，在工厂去做处理的时候，就会产生文件之间的相互影响，导致工厂不能正常的记录这些标签、setup和teardown
【规则14】宏定义文件放到resource目录下，范围相近的常量，放在同一文件里面；
例如：
 

每个宏定义后面添加注释：
 
【规则15】入厂脚本中不能有多余的注释：
正确的格式：
 错误的格式：
 

